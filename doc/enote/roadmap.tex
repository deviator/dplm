\newpage
\section{Реализация симулятора}

Главной частью работы является программное обеспечение для моделирования
массива. Основным краеугольным камнем можно считать быстродействие системы, 
так как одним из требований к конечному продукту была работа в реальном масштабе
времени.

\newpage
\subsection{Модель карты местности}

На данном этапе выполенения работы было решено хранить информацию о местности в
виде дискретной карты, с ограничениями по высоте, глубине и ширине. Карта
представляет из себя массив прямоугольных секторов, хранящих фиксированный объём
информации:
\begin{mintemize}
    \item факт обследованности
    \item наличие объекта
\end{mintemize}

Реализация карты представляет собой 1-мерный массив, к которому можно обратиться с помощью трёх
индексов-координат.

Правила перевода индекса в координаты и обратно:

\nextverbatimspread{1}
\begin{verbatim}
    z = index / ( width * height )
    tmp = index % ( width * height )
    y = tmp / width
    x = tmp % width

    index = z * width * height + y * width + x
\end{verbatim}
\vspace{-0.5em}

где:

\verb|a / b| -- целочисленное деление \verb|a| на \verb|b|;

\verb|a % b| -- остаток от деления \verb|a| на \verb|b|;

\verb|index| -- индекс в одномерном массиве;

\verb|width| -- ширина поля;

\verb|height| -- высота поля;

\verb|x,y,z| -- координаты по ширине, высоте и глубине соответственно.

Так же для карты имеется матрица трансформации координат из локальных (индексов)
в глобальные (метры).

При разрешении карты $400 \times 400 \times 50$ получаем $8 \cdot 10^6$ секторов.
Обработку таких объёмов данных было решено производить с помощью гетерогенных 
вычислений на GPU. Была использована технология \verb|OpenCL|. Это так же 
позволяет решить вопрос отображения данных через \verb|OpenGL|, так как
интероперабельность с графической системой использует zero-copy память -- 
физически это один участок памяти для буферов \verb|OpenCL| и \verb|OpenGL|.

\newpage
\subsection{Модель единицы массива}

За основу была взята концепция БПЛА с вертикальным взлётом (коптер или вертолёт),
тоесть юнит имеет возможность зависать в точке и резко изменять направление движения.

На данном этапе работы математическая модель движения юнита очень проста:
$$
\left\{
    \begin{array}{l l}
    \dot{\vec{p}}  & = \vec V \\
    \dot{\vec{V}}  & = \vec a + \vec g
    \end{array}
\right.
$$

где:

$\vec p = (x,y,z)^T$ -- координаты юнита,

$\vec V = (V_x,V_y,V_z)^T$ -- скорость юнита,

$\vec a$ -- ускорение, вычисленное, как сумма всех сил делённая на массу,

$\vec g$ -- ускорение свободного падения,

$$ \vec a = \frac{1}{m} \cdot limit \left( \sum_{i=0}^N \vec f_N \right) $$

где:

$m$ -- масса юнита,

$limit \left( \vec f \right)$ -- вектор-функция, представляющая ограничение
по максимальной тяге двигателей юнита;

$\vec f_N$ -- управляющие силы.

К списку управляющих сил, в данной реализации алгоритма, относятся: 
\vspace{-0.5em}
\begin{mintemize}
    \item $\vec f_{\text{тр}} = -\vec V \cdot |V| \cdot C_x \cdot S \cdot \rho / 2$ -- сила трения о воздух,

    \item $\vec f_{\text{п}} = (0,0,-9.81 \cdot m)^T$ -- константная сила, компенсирующая силу тяжести,
        введена в архитектурных целях (в дальнейшем планируется изменить модель юнита
        для большей схожести с квадрокоптером)

    \item $\vec f_{\text{ц}}$ -- сила, реализующая движение к заданной точке
    \item $\vec f_{\text{б}}$ -- коррекция по ближайшим юнитам
    \item $\vec f_{\text{к}}$ -- коррекция по известной карте
\end{mintemize}

Список сил возможно будет меняться в процессе реализации нового функционала, либо при переработке старого.

\newpage
Примерный код функции $limit \left( \vec f \right)$:

\nextverbatimspread{1}
\begin{verbatim}
    vec3 limit( vec3 f )
    {
        if( f.xy.len > max_horisontal_force )
            f.xy = f.xy.e * max_horisontal_force;
        if( f.z > max_up_force ) f.z = max_up_force;
        if( f.z < min_up_force ) f.z = min_up_force;
        return f;
    }
\end{verbatim}

где:

\verb|f.xy| -- вектор, составленный из компонент вектора \verb|f|,

\verb|f.xy.len| -- длина вектора,

\verb|f.xy.e| -- единичный вектор.

Такой алгоритм обрезки максимальной тяги позволяет в горизонтальной плоскости двигаться к цели прямолинейно,
а выход на требуемую высоту происходит максимально быстро.

\subsection{Модель измерителей и заполнение карты}

Предполагается что каждый юнит имеет возможность
оценить дальность в любом направлении, в нескольких точках одновременно с определённым 
угловым разрешением (карта глубин). Также предполагается, что каждый юнит знает точно положение и скорость
свои и остальных юнитов в массиве.

Каждый юнит получает информацю о мире с помощью датчика глубины в виде картинки,
где каждому пикселю соответствует измерение дальности в определённых угловых координатах. В работе не эмулировлись
дистрозийные искажения, поэтому для приведения карты глубин в точки в системе координат юнита достаточно 
матрицы перспективной трансформации, которая имеется у каждого юнита. Она так же может меняться в процессе работы
системы при необходимости (изменение угла обзора, зум). После получения точек в связанной системе координат они приводятся
сначала к мировой, затем к системе координат карты. Так же приводится положение юнита (камеры) к системе координат карты.
Заполняется карта по следующему алгоритму: строится отрезок из точки камеры к точке, полученной с датчика, все сектора, которые
находятся между помечаются как исследованные, сектор, в котором находится точка с датчика помечается как заполненая.

\subsection{Логика перемещения юнитов}

Для системы в целом ставится задача полностью исследовать объём, отражаемый в карте.
Из этого следует что каждый юнит направляется к ближайшему неизведанному участку. 
На рисунке можно видеть жёлтые области -- эти области не обошёл сенсором ни один юнит.

\subsection{Алгоритм перемещения юнитов}

Важно чтобы юниты не сталкивались друг с другом и не врезались в стены.
Для этого предусмотрены 2 алгоритма коррекции направления движения юнита: 
\begin{mintemize}
    \item каждый юнит проверяет все остальные на предмет сближения и пересечения моментальной траектории
            (луч из юнита в направлении перемещения)
    \item происходит обращение к карте в целях получения ближайших заполненных секторов
\end{mintemize}

